function [modelSpecific,modelConsistent,inconsistRxns] = createSpecificModel(modelGeneric,coreRxnAbbr,coreRxnWeights,noRxnAbbr,noRxnWeights,EntrezGeneID,EntrezGeneIDWeights,fluxEpsilon)
% create cell/tissue/organ specific model from a generic model
%
%INPUT
% model               Model in COBRA toolbox format e.g. ReconX
% coreRxnAbbr
% coreRxnWeights
% noRxnAbbr
% noRxnWeights
% EntrezGeneID
% EntrezGeneIDWeights
% activeReactions     reactions that must be part of the core set
% inactiveReactions   reactions that must not be part of the core set
% genes               genes that are expressed within the cell (optionally with weights)
% transportGenes      genes for transporters that are expressed within the cell
%
%OPTIONAL INPUT
% fluxEpsilon   {(feasTol*100),double} lowest value of flux that is considered non-zero in
%               flux consistency check
%
%
%OUTPUT
% modelSpecific cell/tissue/organ specific model in COBRA toolbox format
%
% Ines Thiele, June 2015
% Diana El Assal, June 2017: updates of model structure
% Thomas Pfau, J.Modamio October 2017: add updates to the code 
% Agnieszka Wegrzyn 2019: updated the code L151-L172

if 0
    initCobraToolbox;
    changeCobraSolver('tomlab_cplex','lp');
end

if ~exist('fluxEpsilon','var')
    feasTol = getCobraSolverParams('LP', 'feasTol');
    fluxEpsilon = feasTol*100;
end

%Maintain original input model
modelCoupled = modelGeneric;

%remove reactions that are defined not to be able to carry flux
if ~isempty(noRxnAbbr)
    modelGeneric = removeRxns(modelGeneric,noRxnAbbr);
end

%Augments the existing stoichiometry to add one row per gene. The
%corresponding stoichiometry is =1 when that gene is used in a particular
%reaction. Further aguments exsting stoichiometry to add one column per
%gene, with corresponding stoichiometry =-1. If gene is in the core set,
%then the dummy reaction for the gene is required to be active
if ~isempty(EntrezGeneID)
    [modelGeneric,coreRxnAbbrDummy,WeightsPerRxnOrgan] = createDummyModel_old(modelGeneric,EntrezGeneID, EntrezGeneIDWeights);% Recon 2 %TODO - accelerate this step.
    coreRxnAbbr =[coreRxnAbbr; coreRxnAbbrDummy'];
end
%unique core reactions
coreRxnAbbr = unique(coreRxnAbbr);%TODO - check if this is necessary 

% clean up constraints
% %modelGeneric.lb(modelGeneric.lb<0)=-1000;
% %modelGeneric.ub(modelGeneric.ub>0)=1000;
% % modelGeneric.lb(modelGeneric.lb<0)=-1000;
% % modelGeneric.ub(modelGeneric.ub>0)=1000;

%Depreciated:
% modelGeneric.rev(length(modelGeneric.ub))=0;
% modelGeneric.rev(modelGeneric.lb<0)=1;

%generate flux consistent model
%[A,modelFlipped,V] = fastcc(modelGeneric, fluxEpsilon,2,1);
% [A] = fastcc(modelGeneric, fluxEpsilon, 0, 1);
[A] = fastcc(modelGeneric, fluxEpsilon, 0);
consistRxnsModel = modelGeneric.rxns(A);
inconsistRxns = setdiff(modelGeneric.rxns,consistRxnsModel);
modelConsistent = removeRxns(modelGeneric,inconsistRxns);

%define core reactions from model
coreConsistentRxns = find(ismember(modelConsistent.rxns,coreRxnAbbr));
coreConsistentRxns = sort(coreConsistentRxns);

% solve problem by finding the most compact subnetwork containing all core reactions
% save('createSpecificModelDebug','coreConsistentRxns', 'modelConsistent', 'fluxEpsilon')
A2 = fastcore(modelConsistent, coreConsistentRxns, fluxEpsilon, 0);

%remove the reactions not in the subnetwork generated by fastCore
ind = findRxnIDs(modelConsistent, A2.rxns);
cellModelRxns = modelConsistent.rxns(ind);
notCellRxns = setdiff(modelConsistent.rxns,cellModelRxns);
modelSpecific = removeRxns(modelConsistent,notCellRxns);

% remove dummy reactions and metabolites
%reduce size of model
R2 = strmatch(strcat('dummy'),modelSpecific.rxns);
if 1
    modelSpecific = removeRxns(modelSpecific,modelSpecific.rxns(R2));
    % remove dummy metabolites
    M2 = strmatch(strcat('dummy'),modelSpecific.mets);
    modelSpecific = removeMetabolites(modelSpecific,modelSpecific.mets(M2),true);
%     modelSpecific.mets(M2)=[];
%     modelSpecific.metCharge(M2)=[];
%     modelSpecific.metFormulas(M2)=[];
%     modelSpecific.metNames(M2)=[];
%     modelSpecific.b(M2)=[];
%     modelSpecific.S(M2,:)=[];
else
    % remove dummy reactions and metabolites simultaneously
    modelSpecific = removeRxns(modelSpecific,modelSpecific.rxns(R2),0,1);   
end

% adding changes 
modelSpecific = removeUnusedGenes(modelSpecific); %% change by Thomas pfau (maintain consistency between genes and grRules) 

% % update model.genes (updateGenes.m)
% grRules = modelSpecific.grRules;
% [~,n] = size(modelSpecific.S);
% genes = {''};
% for i = 1:n
%     if length(grRules{i}) > 0
%         tmp = grRules{i};
%         tmp = strrep(tmp,'and','');
%         tmp = strrep(tmp,'or','');
%         tmp = strrep(tmp,'(','');
%         tmp = strrep(tmp,')','');
%         tmp = splitString(tmp,' ');
%         genes{end+1, 1} = tmp{:,1};
%     end
% end
% genes = unique(genes(cellfun('isclass',genes,'char')));
% modelSpecific.genes = genes(~cellfun('isempty',genes));

% this is already done in removeUnusedGenes, therefore no need to do it
% here (Thomas) 

% %update model.rxnGeneMat (required for findGenesFromRxns):
% modelSpecific = rmfield(modelSpecific, 'rxnGeneMat');
% modelSpecific = buildRxnGeneMat(modelSpecific);
% %keyboard
% % Double check that the genes were correctly added:
% genes1 = reOrder(findGenesFromRxns(modelSpecific, modelSpecific.rxns));
% genes1 = reshape(genes1, [],1);
% genes1 = genes1(~cellfun('isempty',genes1));
% for i = 1:length(genes1);
%     genes1{i} = char(genes1{i});
% end;
% modelSpecific.genes1 = unique(genes1(cellfun('isclass',genes1,'char')));
% if length(modelSpecific.genes1) == length(modelSpecific.genes);
%     modelSpecific = rmfield(modelSpecific, 'genes1');
% else
%     warning('The genes were not correctly updated in the new model');
% end


%update model.C matrix using the original input model
% no need to do that, model.C and model.csense are kept consistent (Aga)
% if ~isfield(modelCoupled, 'C');
%     modelSpecific.C = [];
% else
%     modelSpecific.C = false(numel(modelSpecific.d), numel(modelSpecific.rxns));
%     indCoupled = findRxnIDs(modelSpecific, modelCoupled.coupledRxns);
%     modelSpecific.csense = '';
%     modelSpecific.csense(1:length(modelSpecific.mets), 1) = 'E';
%     nd = modelSpecific.d;
%     for i = 1:length(nd);
%         ncsense = length(modelSpecific.csense);
%         modelSpecific.csense((ncsense+1),1) = 'G';
%     end
%     for i=1:length(indCoupled);
%         ind=modelCoupled.coupledRxnInds(1,i);
%         pos = find(modelCoupled.C(:,ind));
%         if ~(indCoupled(i))==0
%             modelSpecific.C(pos, indCoupled(i))= 1;
%         end
%     end
% end

% no need to do that. model field order kept consistent (Thomas)

% %Clean up redundant or disorganised model fields
% fields2remove = {
%     'biomassRxnAbbr'
%     'match'
%     'metCHEBIID'
%     'metInchiString'
%     'metKeggID'
%     'metPubChemID'
%     'rev'};
% for i = 1:length(fields2remove);
%     if isfield(modelSpecific, fields2remove(i));
%         modelSpecific = rmfield(modelSpecific, fields2remove(i));
%     end
% end

end


